/*
*Created by: Juan Murcia and David Moreno
*Last Update: 25/11/2018
*/
#ifndef _RBTree_hpp_
#define _RBTree_hpp_

/*
* enum for the color of the nodes
*/
enum Color {
	RED, BLACK
};

/*
*Class that recrates the ADT red black trees
*/
template <typename keyType, typename dataType>
class RBTree {
	private:
		/*
		*Struct for the nodes of the tree
		*pr: pair of elements of the tree
		*left: pointer to the left child of the node
		*right: pointer to the right child of the node
		*parent: pointer to the parent of the node
		*color: color of the node
		*/
		struct RBTNode {
			std::pair<keyType, dataType> pr;
			RBTNode *left;
			RBTNode *right;
			RBTNode *parent;
			Color color;
		};

		//number of nodes in the tree
		size_t count;
		//pointer to the root of the tree
		RBTNode *root;
		/*
		*Function that searches the minimum key at the tree
		*root: root of the subtree
		*return: pointer the node with the minimun key, nullptr if root has no left child
		*/
		RBTNode * min(RBTNode *root) const;
		/*
		*Function that searches the maximum key at the tree
		*root: root of the subtree
		*return: pointer to the node with the maximum key, nullptr if root has no right child
		*/
		RBTNode * max(RBTNode *root) const;
		/*
		*Function that searches the lowest key of the largest keys
		*root: root of the subtree
		*return: pointer to the node with the successor, nullptr if root has no right child
		*/
		RBTNode * successor(RBTNode *root) const;
		/*
		*Function that searches the largest key of the smallest keys
		*root: root of the subtree
		*return: pointer to the node with the predecessor, nullptr if root has no left child
		*/
		RBTNode * predecessor(RBTNode *root) const;

		/*
		*Method that rotates a node to the left
		*node: node that will be rotated
		*/
		void rotateLeft(RBTNode *node);
		/*
		*Method that rotates a node to the right
		*node: node that will be rotated
		*/
		void rotateRight(RBTNode *node);
		/*
		*Method that fixes the violations generated by standart BST insertion
		*node: node that was inserted
		*/
		void fixRedRed(RBTNode *node);
		/*
		*Method that swap the positions of a node A with another node B, and A becomes a child of B
		*node: node that will be raplaced
		*nParent: node that will become the new parent of the original node
		*/
		void moveDown(RBTNode *node, RBTNode *nParent);

		/*
		*Function that searches the uncle of a node
		*node: pointer to a node
		*return: the sibling of the parent of node, nullptr if node has no parent or grandparent
		*/
		RBTNode * Uncle(RBTNode *node);
		/*
		*Function that searches the sibling of a node
		*node: pointer to a node
		*return: the other child of the parent of node, nullptr if node has no parent
		*/
		RBTNode *sibling(RBTNode *node);
		/*
		*Function that determines if a node has a red child
		*node: pointer to a node
		*return: true if node has a red child, false if not
		*/
		bool hasRedChild(RBTNode *node);
		/*
		*Function that searches the node that will replace a node that wil be deleted
		*node: pointer to a node
		*return: the succesor of node if node has two childs, nullptr if node has no childs, or the unique child of node if has only one child
		*/
		RBTNode *BSTreplace(RBTNode *node);
		/*
		*Method that removes a node in the tree
		*v: node that will be deleted
		*/
		void remove(RBTNode *v);
		/*
		*Method that fixes the violations genereted by standart BST deletion
		*node: node that breaks a propiety of the RBT
		*/
		void fixDoubleBlack(RBTNode *node);

		/*
		*Function that creates a copy of a node
		*rooot: node that will be copied
		*parent: parent for the new node
		*return: a copy of root
		*/
		RBTNode * copy(RBTNode *root, RBTNode *parent = nullptr);
		/*
		*Method that clears a subtree
		*root: pointer to the root of the subtree
		*/
		void clear(RBTNode *root);
		/*
		*Method that inserts to an ostream the contents of the tree
		*root: pointer to the root of the subtree
		*out: ostream for the insertions
		*max: the maximum key of the tree
		*/
		void display(RBTNode *root, std::ostream & out, keyType max) const;
		/*
		*Function that finds the node with an specific key
		*key: key for the node
		*return: node that contains the key, if the tree has not key in it, return the posible parent for key
		*/
		RBTNode * Find(keyType key) const;

	public:
		/*
		*Constructor, creates a new RBTree
		*/
		RBTree();
		/*
		*Copy constructor, creates a new RBTree, identical to another one
		*rhs: the other RBTree
		*/
		RBTree(const RBTree & rhs);
		/*
		*Destructor, deletes the actual RBTree
		*/
		~RBTree();
		/*
		*Function that removes from the tree the pair with the an specific key
		*key: key of the pair that want to be deleted
		*return: true if the pair was removed from the tree, false if the kay was not in the tree
		*/
		bool remove(keyType key);
		/*
		*Function that determines if the tree is empty
		*return: true if the tree is empty, false if not
		*/
		bool empty(void) const;
		/*
		*Method that clears a tree
		*/
		void clear(void);
		/*
		*Function that determines the number of elements at the tree
		*return: the number of elements at the tree
		*/
		size_t size(void) const;
		/*
		*Function that searches a pair with an specific key
		*key: key that will be searched
		*return: true if there is a pair with that key in the tree, false if not
		*/
		bool find(keyType key) const;
		/*
		*Function that inserts a new pair to the tree
		*key: key of the pair
		*data: value of the pair
		*return: true if the pair was inserted, false if a pair with that key was already in the tree
		*/
		bool insert(keyType key, dataType data);
		/*
		*Method that displays the tree in standart output
		*out: the output for the tree, std::cout default
		*/
		void display(std::ostream &out = std::cout) const;
		/*
		*Overloads the assigment operator for the RBTree
		*rhs: RBTree for the assigment
		*return: a reference to a new RBTree identical to rhs
		*/
		RBTree<keyType, dataType> & operator=(const RBTree<keyType, dataType> & rhs);
		/*
		*Overloads the operator [] for the RBTree
		*key: the key of the value
		*a reference to the value with that key
		*/
		dataType & operator[](keyType key);
		/*
		*Function that search the value that has an specific key
		*key: the key of the value
		*return: reference to the veue wiith that key
		*/
		dataType & at(keyType key);
		/*
		*Method that swaps the values of two keys
		*dt1: forst value
		*dt2: second valie
		*/
		void swap(dataType & dt1, dataType & dt2);
};

#include "RBTree.cpp"

#endif //_RBTree_hpp_

//the way to do the insertion and deletion of elements was obtained at GeeksforGeeks